{"version":3,"sources":["../../../../../frontend/app/products/ProductsPageClient.tsx","../../../../../frontend/node_modules/%40tanstack/react-query/build/modern/QueryErrorResetBoundary.js","../../../../../frontend/node_modules/%40tanstack/react-query/build/modern/errorBoundaryUtils.js","../../../../../frontend/node_modules/%40tanstack/react-query/build/modern/IsRestoringProvider.js","../../../../../frontend/node_modules/%40tanstack/react-query/build/modern/suspense.js","../../../../../frontend/node_modules/%40tanstack/react-query/build/modern/useBaseQuery.js","../../../../../frontend/node_modules/%40tanstack/react-query/build/modern/useQuery.js","../../../../../frontend/lib/hooks/useProducts.ts","../../../../../frontend/lib/hooks/useCategories.ts","../../../../../frontend/lib/hooks/useOrders.ts","../../../../../frontend/lib/hooks/useUsers.ts","../../../../../frontend/node_modules/%40tanstack/query-core/build/modern/queryObserver.js","../../../../../frontend/lib/hooks/useSocketConnection.ts"],"sourcesContent":["'use client';\n\nimport { useState, useMemo } from 'react';\nimport { Search } from 'lucide-react';\nimport ProductGrid from '@/components/ProductGrid';\nimport { useProducts, useCategories } from '@/lib/hooks';\nimport { ProductCardSkeleton, PageHeaderSkeleton } from '@/components/ui/skeleton';\nimport Button from '@/components/ui/Button';\nimport type { Category } from '@/types';\n\nexport default function ProductsPageClient() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState<string>('');\n  const [sortBy, setSortBy] = useState<'createdAt' | 'price' | 'title'>('createdAt');\n  const [page, setPage] = useState(1);\n\n  // Fetch categories using React Query (cached for 10 minutes)\n  const { data: categoriesData } = useCategories();\n\n  // Fetch products using React Query (cached for 5 minutes)\n  const { data: productsData, isLoading: loadingProducts } = useProducts({\n    page,\n    limit: 12,\n    sortBy,\n    category: selectedCategory || undefined,\n    search: searchTerm || undefined,\n  });\n\n  // Memoize categories to only active ones\n  const categories = useMemo(\n    () => categoriesData?.filter((cat: Category) => cat.isActive) || [],\n    [categoriesData]\n  );\n\n  // Extract product data\n  const products = productsData?.data || [];\n  const totalPages = productsData?.pagination?.pages || 1;\n  const totalProducts = productsData?.pagination?.total || 0;\n\n  const handleSearch = (value: string) => {\n    setSearchTerm(value);\n    setPage(1);\n  };\n\n  const handleCategoryChange = (categoryId: string) => {\n    setSelectedCategory(categoryId);\n    setPage(1);\n  };\n\n  const handleSortChange = (sort: typeof sortBy) => {\n    setSortBy(sort);\n  };\n\n  // Memoized stats\n  const statsText = useMemo(() => {\n    return `${totalProducts} ${totalProducts === 1 ? 'product' : 'products'} found`;\n  }, [totalProducts]);\n\n  if (loadingProducts && page === 1) {\n    return (\n      <div className=\"container mx-auto px-4 py-8\">\n        <PageHeaderSkeleton showSubtitle showActions={false} />\n        <div className=\"mt-8 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6\">\n          <ProductCardSkeleton count={8} />\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"container mx-auto px-4 py-8\">\n      {/* Header */}\n      <div className=\"mb-8\">\n        <h1 className=\"text-3xl font-bold mb-2\">Browse Products</h1>\n        <p className=\"text-muted-foreground\">{statsText}</p>\n      </div>\n\n      {/* Filters */}\n      <div className=\"mb-6 space-y-4\">\n        {/* Search and Sort */}\n        <div className=\"flex flex-col md:flex-row gap-4\">\n          <div className=\"flex-1 relative\">\n            <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n            <input\n              type=\"text\"\n              placeholder=\"Search products...\"\n              value={searchTerm}\n              onChange={(e) => handleSearch(e.target.value)}\n              className=\"w-full pl-10 pr-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-primary\"\n            />\n          </div>\n\n          <div className=\"flex gap-2\">\n            <select\n              value={sortBy}\n              onChange={(e) => handleSortChange(e.target.value as typeof sortBy)}\n              className=\"px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-primary\"\n            >\n              <option value=\"createdAt\">Newest</option>\n              <option value=\"price\">Price: Low to High</option>\n              <option value=\"title\">Name: A to Z</option>\n            </select>\n          </div>\n        </div>\n\n        {/* Categories */}\n        <div className=\"flex flex-wrap gap-2\">\n          <Button\n            size=\"sm\"\n            variant={selectedCategory === '' ? 'primary' : 'outline'}\n            onClick={() => handleCategoryChange('')}\n          >\n            All Categories\n          </Button>\n          {categories.map((category) => (\n            <Button\n              key={category._id}\n              size=\"sm\"\n              variant={selectedCategory === category._id ? 'primary' : 'outline'}\n              onClick={() => handleCategoryChange(category._id)}\n            >\n              {category.icon} {category.name}\n            </Button>\n          ))}\n        </div>\n      </div>\n\n      {/* Products Grid */}\n      {products.length === 0 && !loadingProducts ? (\n        <div className=\"text-center py-16\">\n          <div className=\"text-6xl mb-4\">üîç</div>\n          <h2 className=\"text-2xl font-semibold mb-2\">No products found</h2>\n          <p className=\"text-muted-foreground mb-6\">\n            Try adjusting your filters or search terms\n          </p>\n          <Button onClick={() => { setSearchTerm(''); setSelectedCategory(''); }}>\n            Clear Filters\n          </Button>\n        </div>\n      ) : (\n        <>\n          <ProductGrid products={products} loading={loadingProducts && page > 1} />\n\n          {/* Pagination */}\n          {totalPages > 1 && (\n            <div className=\"flex justify-center items-center space-x-2 mt-8\">\n              <Button\n                onClick={() => setPage(p => Math.max(1, p - 1))}\n                disabled={page === 1}\n                variant=\"outline\"\n                size=\"sm\"\n              >\n                Previous\n              </Button>\n              <span className=\"text-sm\">\n                Page {page} of {totalPages}\n              </span>\n              <Button\n                onClick={() => setPage(p => Math.min(totalPages, p + 1))}\n                disabled={page === totalPages}\n                variant=\"outline\"\n                size=\"sm\"\n              >\n                Next\n              </Button>\n            </div>\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"@tanstack/query-core\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary, query) => {\n  const throwOnError = query?.state.error && typeof options.throwOnError === \"function\" ? shouldThrowError(options.throwOnError, [query.state.error, query]) : options.throwOnError;\n  if (options.suspense || options.experimental_prefetchInRender || throwOnError) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","\"use client\";\n\n// src/IsRestoringProvider.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=IsRestoringProvider.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    const MIN_SUSPENSE_TIME_MS = 1e3;\n    const clamp = (value) => value === \"static\" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);\n    const originalStaleTime = defaultedOptions.staleTime;\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(\n        defaultedOptions.gcTime,\n        MIN_SUSPENSE_TIME_MS\n      );\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, noop, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const client = useQueryClient(queryClient);\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  const query = client.getQueryCache().get(defaultedOptions.queryHash);\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary, query);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query,\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      query?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","\"use client\";\n\n// src/useQuery.ts\nimport { QueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useQuery(options, queryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient);\n}\nexport {\n  useQuery\n};\n//# sourceMappingURL=useQuery.js.map","'use client';\n\nimport { useQuery, useMutation, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';\nimport { productsAPI } from '@/lib/api/products';\nimport type { Product, PaginationResponse, Filters } from '@/types';\n\n/**\n * Query keys for products\n * Used for cache management and invalidation\n */\nexport const productKeys = {\n  all: ['products'] as const,\n  lists: () => [...productKeys.all, 'list'] as const,\n  list: (filters?: Filters & { page?: number; limit?: number }) =>\n    [...productKeys.lists(), filters] as const,\n  details: () => [...productKeys.all, 'detail'] as const,\n  detail: (id: string) => [...productKeys.details(), id] as const,\n  seller: (sellerId: string) => [...productKeys.all, 'seller', sellerId] as const,\n  sold: () => [...productKeys.all, 'sold'] as const,\n  related: (id: string) => [...productKeys.all, 'related', id] as const,\n};\n\n/**\n * Custom hook to fetch products with optional filters\n *\n * @param params - Optional filters and pagination\n * @param options - React Query options\n * @returns Products query result\n */\nexport function useProducts(\n  params?: Filters & { page?: number; limit?: number },\n  options?: Partial<UseQueryOptions<PaginationResponse<Product>>>\n) {\n  return useQuery({\n    queryKey: productKeys.list(params),\n    queryFn: () => productsAPI.getProducts(params).then(res => res.data),\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch a single product by ID\n *\n * @param id - Product ID\n * @param options - React Query options\n * @returns Product query result\n */\nexport function useProduct(\n  id: string,\n  options?: Partial<UseQueryOptions<Product>>\n) {\n  return useQuery({\n    queryKey: productKeys.detail(id),\n    queryFn: () => productsAPI.getProduct(id).then(res => res.data.product),\n    enabled: !!id, // Only run query if id is provided\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch products by seller\n *\n * @param sellerId - Seller user ID\n * @param params - Optional pagination\n * @param options - React Query options\n * @returns Products query result\n */\nexport function useSellerProducts(\n  sellerId: string,\n  params?: { page?: number; limit?: number },\n  options?: Partial<UseQueryOptions<PaginationResponse<Product>>>\n) {\n  return useQuery({\n    queryKey: [...productKeys.seller(sellerId), params],\n    queryFn: () =>\n      productsAPI.getSellerProducts(sellerId, params).then(res => res.data),\n    enabled: !!sellerId,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch sold products history\n *\n * @param params - Optional filters and pagination\n * @param options - React Query options\n * @returns Sold products query result\n */\nexport function useSoldProducts(\n  params?: {\n    sortBy?: string;\n    sortOrder?: string;\n    page?: number;\n    limit?: number;\n  },\n  options?: Partial<UseQueryOptions<PaginationResponse<Product>>>\n) {\n  return useQuery({\n    queryKey: [...productKeys.sold(), params],\n    queryFn: () => productsAPI.getSoldProducts(params).then(res => res.data),\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch related products\n *\n * @param id - Product ID\n * @param options - React Query options\n * @returns Related products query result\n */\nexport function useRelatedProducts(\n  id: string,\n  options?: Partial<UseQueryOptions<Product[]>>\n) {\n  return useQuery({\n    queryKey: productKeys.related(id),\n    queryFn: () =>\n      productsAPI.getRelatedProducts(id).then(res => res.data.products),\n    enabled: !!id,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to toggle like on a product\n *\n * @returns Mutation object for toggling likes\n */\nexport function useToggleLike() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => productsAPI.toggleLike(id),\n    onSuccess: (response, id) => {\n      // Invalidate the specific product query\n      queryClient.invalidateQueries({ queryKey: productKeys.detail(id) });\n\n      // Invalidate products list queries to update like counts\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to create a new product\n *\n * @returns Mutation object for creating products\n */\nexport function useCreateProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: FormData) => productsAPI.createProduct(data),\n    onSuccess: () => {\n      // Invalidate products list queries\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to update a product\n *\n * @returns Mutation object for updating products\n */\nexport function useUpdateProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, data }: { id: string; data: FormData }) =>\n      productsAPI.updateProduct(id, data),\n    onSuccess: (response, { id }) => {\n      // Invalidate the specific product query\n      queryClient.invalidateQueries({ queryKey: productKeys.detail(id) });\n\n      // Invalidate products list queries\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n\n      // Invalidate seller products queries\n      queryClient.invalidateQueries({ queryKey: productKeys.seller(response.data.product.seller._id) });\n    },\n  });\n}\n\n/**\n * Custom hook to delete a product\n *\n * @returns Mutation object for deleting products\n */\nexport function useDeleteProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => productsAPI.deleteProduct(id),\n    onSuccess: () => {\n      // Invalidate products list queries\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to relist a sold/delisted product\n *\n * @returns Mutation object for relisting products\n */\nexport function useRelistProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, data }: { id: string; data: Partial<Product> }) =>\n      productsAPI.relistProduct(id, data),\n    onSuccess: () => {\n      // Invalidate products list queries\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n\n      // Invalidate sold products queries\n      queryClient.invalidateQueries({ queryKey: productKeys.sold() });\n    },\n  });\n}\n","'use client';\n\nimport { useQuery, useMutation, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';\nimport { categoriesAPI } from '@/lib/api/categories';\nimport type { Category, Product, PaginationInfo } from '@/types';\n\n/**\n * Query keys for categories\n * Used for cache management and invalidation\n */\nexport const categoryKeys = {\n  all: ['categories'] as const,\n  lists: () => [...categoryKeys.all, 'list'] as const,\n  list: () => [...categoryKeys.lists()] as const,\n  details: () => [...categoryKeys.all, 'detail'] as const,\n  detail: (id: string, params?: { page?: number; limit?: number }) =>\n    [...categoryKeys.details(), id, params] as const,\n};\n\n/**\n * Custom hook to fetch all categories with product counts\n *\n * Categories are cached for 10 minutes since they rarely change\n *\n * @param options - React Query options\n * @returns Categories query result\n */\nexport function useCategories(\n  options?: Partial<UseQueryOptions<(Category & { productCount: number })[]>>\n) {\n  return useQuery({\n    queryKey: categoryKeys.list(),\n    queryFn: () =>\n      categoriesAPI.getCategories().then(res => res.data.categories),\n    staleTime: 10 * 60 * 1000, // 10 minutes - categories rarely change\n    gcTime: 60 * 60 * 1000, // 1 hour - keep categories cached longer\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch a single category with products\n *\n * @param id - Category ID or slug\n * @param params - Optional pagination\n * @param options - React Query options\n * @returns Category query result\n */\nexport function useCategory(\n  id: string,\n  params?: { page?: number; limit?: number },\n  options?: Partial<UseQueryOptions<{\n    category: Category & { productCount: number };\n    products: Product[];\n    pagination: PaginationInfo;\n  }>>\n) {\n  return useQuery({\n    queryKey: categoryKeys.detail(id, params),\n    queryFn: () => categoriesAPI.getCategory(id, params).then(res => res.data),\n    enabled: !!id,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to create a new category\n *\n * @returns Mutation object for creating categories\n */\nexport function useCreateCategory() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: {\n      name: string;\n      description?: string;\n      icon?: string;\n      image?: string;\n      parentCategory?: string;\n    }) => categoriesAPI.createCategory(data),\n    onSuccess: () => {\n      // Invalidate categories list queries\n      queryClient.invalidateQueries({ queryKey: categoryKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to update a category\n *\n * @returns Mutation object for updating categories\n */\nexport function useUpdateCategory() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, data }: {\n      id: string;\n      data: {\n        name?: string;\n        description?: string;\n        icon?: string;\n        image?: string;\n        isActive?: boolean;\n      };\n    }) => categoriesAPI.updateCategory(id, data),\n    onSuccess: (response, { id }) => {\n      // Invalidate the specific category query\n      queryClient.invalidateQueries({ queryKey: categoryKeys.details() });\n\n      // Invalidate categories list queries\n      queryClient.invalidateQueries({ queryKey: categoryKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to delete a category\n *\n * @returns Mutation object for deleting categories\n */\nexport function useDeleteCategory() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => categoriesAPI.deleteCategory(id),\n    onSuccess: () => {\n      // Invalidate categories list queries\n      queryClient.invalidateQueries({ queryKey: categoryKeys.lists() });\n    },\n  });\n}\n","'use client';\n\nimport { useQuery, useMutation, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';\nimport { ordersAPI } from '@/lib/api/orders';\nimport type { Order, PaginationResponse, ShippingAddress, PayoutLedger } from '@/types';\n\n/**\n * Query keys for orders\n * Used for cache management and invalidation\n */\nexport const orderKeys = {\n  all: ['orders'] as const,\n  lists: () => [...orderKeys.all, 'list'] as const,\n  list: (params?: { page?: number; limit?: number; status?: string; as?: string }) =>\n    [...orderKeys.lists(), params] as const,\n  details: () => [...orderKeys.all, 'detail'] as const,\n  detail: (id: string) => [...orderKeys.details(), id] as const,\n  session: (sessionId: string) => [...orderKeys.all, 'session', sessionId] as const,\n  payouts: () => [...orderKeys.all, 'payouts'] as const,\n  payoutLedger: (params?: { page?: number; limit?: number }) =>\n    [...orderKeys.payouts(), 'ledger', params] as const,\n};\n\n/**\n * Custom hook to fetch orders with optional filters\n *\n * @param params - Optional filters and pagination\n * @param options - React Query options\n * @returns Orders query result\n */\nexport function useOrders(\n  params?: {\n    page?: number;\n    limit?: number;\n    status?: string;\n    as?: string;\n  },\n  options?: Partial<UseQueryOptions<PaginationResponse<Order>>>\n) {\n  return useQuery({\n    queryKey: orderKeys.list(params),\n    queryFn: () => ordersAPI.getOrders(params).then(res => res.data),\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch a single order by ID\n *\n * @param id - Order ID\n * @param options - React Query options\n * @returns Order query result\n */\nexport function useOrder(\n  id: string,\n  options?: Partial<UseQueryOptions<Order>>\n) {\n  return useQuery({\n    queryKey: orderKeys.detail(id),\n    queryFn: () => ordersAPI.getOrder(id).then(res => res.data.order),\n    enabled: !!id,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch orders by checkout session ID\n *\n * @param sessionId - Checkout session ID\n * @param options - React Query options\n * @returns Orders query result\n */\nexport function useOrdersBySession(\n  sessionId: string,\n  options?: Partial<UseQueryOptions<Order[]>>\n) {\n  return useQuery({\n    queryKey: orderKeys.session(sessionId),\n    queryFn: () =>\n      ordersAPI.getOrdersBySession(sessionId).then(res => res.data.orders),\n    enabled: !!sessionId,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch payout ledger (admin only)\n *\n * @param params - Optional pagination\n * @param options - React Query options\n * @returns Payout ledger query result\n */\nexport function usePayoutLedger(\n  params?: { page?: number; limit?: number },\n  options?: Partial<UseQueryOptions<{\n    sellerGroups: PayoutLedger['sellerGroups'];\n    totalOrders: number;\n    totalSellers: number;\n    pendingPayoutTotal: number;\n  }>>\n) {\n  return useQuery({\n    queryKey: orderKeys.payoutLedger(params),\n    queryFn: () => ordersAPI.getPayoutLedger(params).then(res => res.data),\n    ...options,\n  });\n}\n\n/**\n * Custom hook to create a new order\n *\n * @returns Mutation object for creating orders\n */\nexport function useCreateOrder() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: {\n      productId: string;\n      quantity?: number;\n      shippingAddress: ShippingAddress;\n      notes?: string;\n      paymentMethod?: string;\n    }) => ordersAPI.createOrder(data),\n    onSuccess: () => {\n      // Invalidate orders list queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to initiate M-Pesa payment for an order\n *\n * @returns Mutation object for initiating payments\n */\nexport function useInitiatePayment() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, phoneNumber }: { id: string; phoneNumber: string }) =>\n      ordersAPI.initiatePayment(id, { phoneNumber }),\n    onSuccess: (response, { id }) => {\n      // Invalidate the specific order query to check for status updates\n      queryClient.invalidateQueries({ queryKey: orderKeys.detail(id) });\n    },\n  });\n}\n\n/**\n * Custom hook to update order status\n *\n * @returns Mutation object for updating order status\n */\nexport function useUpdateOrderStatus() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, status }: { id: string; status: string }) =>\n      ordersAPI.updateOrderStatus(id, { status }),\n    onSuccess: (response, { id }) => {\n      // Invalidate the specific order query\n      queryClient.invalidateQueries({ queryKey: orderKeys.detail(id) });\n\n      // Invalidate orders list queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to cancel an order\n *\n * @returns Mutation object for canceling orders\n */\nexport function useCancelOrder() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, reason }: { id: string; reason?: string }) =>\n      ordersAPI.cancelOrder(id, { reason }),\n    onSuccess: (response, { id }) => {\n      // Invalidate the specific order query\n      queryClient.invalidateQueries({ queryKey: orderKeys.detail(id) });\n\n      // Invalidate orders list queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to mark a seller as paid (admin)\n *\n * @returns Mutation object for marking seller as paid\n */\nexport function useMarkSellerPaid() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ orderId, notes }: { orderId: string; notes?: string }) =>\n      ordersAPI.markSellerPaid(orderId, { notes }),\n    onSuccess: () => {\n      // Invalidate payout ledger queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.payouts() });\n\n      // Invalidate orders list queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to mark all orders for a seller as paid (admin)\n *\n * @returns Mutation object for batch marking seller as paid\n */\nexport function useMarkSellerPaidBatch() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ sellerId, notes }: { sellerId: string; notes?: string }) =>\n      ordersAPI.markSellerPaidBatch(sellerId, { notes }),\n    onSuccess: () => {\n      // Invalidate payout ledger queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.payouts() });\n\n      // Invalidate orders list queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to checkout cart\n *\n * @returns Mutation object for cart checkout\n */\nexport function useCheckoutCart() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: {\n      shippingAddress: ShippingAddress;\n      phoneNumber: string;\n      paymentMethod?: string;\n      notes?: string;\n    }) => ordersAPI.checkoutCart(data),\n    onSuccess: (response) => {\n      // Invalidate orders list queries\n      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });\n\n      // Invalidate cart queries\n      queryClient.invalidateQueries({ queryKey: ['cart'] });\n    },\n  });\n}\n","'use client';\n\nimport { useQuery, useMutation, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';\nimport { usersAPI } from '@/lib/api/users';\nimport type { User, Product, Order, Review, PaginationInfo, DashboardStats } from '@/types';\n\n/**\n * Query keys for users\n * Used for cache management and invalidation\n */\nexport const userKeys = {\n  all: ['users'] as const,\n  lists: () => [...userKeys.all, 'list'] as const,\n  list: (params?: {\n    page?: number;\n    limit?: number;\n    role?: string;\n    search?: string;\n  }) => [...userKeys.lists(), params] as const,\n  details: () => [...userKeys.all, 'detail'] as const,\n  detail: (id: string) => [...userKeys.details(), id] as const,\n  reviews: (id: string) => [...userKeys.all, 'reviews', id] as const,\n  dashboard: () => [...userKeys.all, 'dashboard'] as const,\n};\n\n/**\n * Custom hook to fetch all users (admin)\n *\n * @param params - Optional filters and pagination\n * @param options - React Query options\n * @returns Users query result\n */\nexport function useUsers(\n  params?: {\n    page?: number;\n    limit?: number;\n    role?: string;\n    search?: string;\n  },\n  options?: Partial<UseQueryOptions<{\n    success: boolean;\n    users: User[];\n    pagination: PaginationInfo;\n  }>>\n) {\n  return useQuery({\n    queryKey: userKeys.list(params),\n    queryFn: () => usersAPI.getUsers(params).then(res => res.data),\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch a user by ID with their products\n *\n * @param id - User ID\n * @param options - React Query options\n * @returns User query result\n */\nexport function useUser(\n  id: string,\n  options?: Partial<UseQueryOptions<User & { products: Product[] }>>\n) {\n  return useQuery({\n    queryKey: userKeys.detail(id),\n    queryFn: () => usersAPI.getUser(id).then(res => res.data.user),\n    enabled: !!id,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch user profile\n *\n * @param id - User ID\n * @param options - React Query options\n * @returns User profile query result\n */\nexport function useUserProfile(\n  id: string,\n  options?: Partial<UseQueryOptions<User>>\n) {\n  return useQuery({\n    queryKey: userKeys.detail(id),\n    queryFn: () => usersAPI.getUserProfile(id).then(res => res.data.user),\n    enabled: !!id,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch user reviews\n *\n * @param id - User ID\n * @param options - React Query options\n * @returns User reviews query result\n */\nexport function useUserReviews(\n  id: string,\n  options?: Partial<UseQueryOptions<Review[]>>\n) {\n  return useQuery({\n    queryKey: userKeys.reviews(id),\n    queryFn: () => usersAPI.getUserReviews(id).then(res => res.data.reviews),\n    enabled: !!id,\n    ...options,\n  });\n}\n\n/**\n * Custom hook to fetch dashboard statistics\n *\n * Dashboard stats are cached for 2 minutes\n *\n * @param options - React Query options\n * @returns Dashboard stats query result\n */\nexport function useDashboardStats(\n  options?: Partial<UseQueryOptions<{\n    stats: DashboardStats;\n    recentProducts: Product[];\n    recentOrders: Order[];\n  }>>\n) {\n  return useQuery({\n    queryKey: userKeys.dashboard(),\n    queryFn: () => usersAPI.getDashboardStats().then(res => res.data),\n    staleTime: 2 * 60 * 1000, // 2 minutes - stats change periodically\n    ...options,\n  });\n}\n\n/**\n * Custom hook to update a user (admin)\n *\n * @returns Mutation object for updating users\n */\nexport function useUpdateUser() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, data }: {\n      id: string;\n      data: {\n        role?: string;\n        isVerified?: boolean;\n        isActive?: boolean;\n      };\n    }) => usersAPI.updateUser(id, data),\n    onSuccess: (response, { id }) => {\n      // Invalidate the specific user query\n      queryClient.invalidateQueries({ queryKey: userKeys.detail(id) });\n\n      // Invalidate users list queries\n      queryClient.invalidateQueries({ queryKey: userKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to delete a user (admin)\n *\n * @returns Mutation object for deleting users\n */\nexport function useDeleteUser() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => usersAPI.deleteUser(id),\n    onSuccess: () => {\n      // Invalidate users list queries\n      queryClient.invalidateQueries({ queryKey: userKeys.lists() });\n    },\n  });\n}\n\n/**\n * Custom hook to reset user password (admin)\n *\n * @returns Mutation object for resetting passwords\n */\nexport function useResetUserPassword() {\n  return useMutation({\n    mutationFn: (id: string) => usersAPI.resetUserPassword(id),\n  });\n}\n","// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { timeoutManager } from \"./timeoutManager.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked?.(key);\n        if (key === \"promise\") {\n          this.trackProp(\"data\");\n          if (!this.options.experimental_prefetchInRender && this.#currentThenable.status === \"pending\") {\n            this.#currentThenable.reject(\n              new Error(\n                \"experimental_prefetchInRender feature flag is not enabled\"\n              )\n            );\n          }\n        }\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const hasResultData = nextResult.data !== void 0;\n      const isErrorWithoutData = nextResult.status === \"error\" && !hasResultData;\n      const finalizeThenableIfPossible = (thenable) => {\n        if (isErrorWithoutData) {\n          thenable.reject(nextResult.error);\n        } else if (hasResultData) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (isErrorWithoutData || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (!isErrorWithoutData || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","'use client';\n\nimport { useEffect, useState, useRef } from 'react';\nimport { useSocket } from '@/contexts/SocketContext';\n\n/**\n * Hook to monitor socket connection state and execute callbacks on state changes\n *\n * @param options - Configuration options\n * @param options.onConnected - Callback when socket connects\n * @param options.onDisconnected - Callback when socket disconnects\n * @param options.onReconnecting - Callback when socket is reconnecting\n * @param options.onError - Callback when connection error occurs\n * @returns Connection state object\n *\n * @example\n * ```tsx\n * const { isConnected, isReconnecting, connectionError } = useSocketConnection({\n *   onConnected: () => console.log('Connected!'),\n *   onDisconnected: () => console.log('Disconnected'),\n * });\n * ```\n */\nexport function useSocketConnection(options?: {\n  onConnected?: () => void;\n  onDisconnected?: () => void;\n  onReconnecting?: (attempt: number) => void;\n  onError?: (error: string | null) => void;\n}) {\n  const { isConnected, isReconnecting, connectionError, reconnectAttempt } = useSocket();\n  const previousStateRef = useRef({\n    isConnected,\n    isReconnecting,\n    connectionError,\n  });\n\n  useEffect(() => {\n    const prevState = previousStateRef.current;\n\n    // Connection established\n    if (isConnected && !prevState.isConnected && options?.onConnected) {\n      options.onConnected();\n    }\n\n    // Disconnected\n    if (!isConnected && !isReconnecting && prevState.isConnected && options?.onDisconnected) {\n      options.onDisconnected();\n    }\n\n    // Started reconnecting\n    if (isReconnecting && !prevState.isReconnecting && options?.onReconnecting) {\n      options.onReconnecting(reconnectAttempt);\n    }\n\n    // Error changed\n    if (connectionError !== prevState.connectionError && options?.onError) {\n      options.onError(connectionError);\n    }\n\n    // Update previous state\n    previousStateRef.current = {\n      isConnected,\n      isReconnecting,\n      connectionError,\n    };\n  }, [isConnected, isReconnecting, connectionError, reconnectAttempt, options]);\n\n  return {\n    isConnected,\n    isReconnecting,\n    connectionError,\n    reconnectAttempt,\n  };\n}\n\n/**\n * Hook to automatically disable actions when socket is disconnected\n *\n * @param disabled - Additional disabled state\n * @returns Combined disabled state\n *\n * @example\n * ```tsx\n * const isDisabled = useSocketDisabled(false);\n * <button disabled={isDisabled}>Send Message</button>\n * ```\n */\nexport function useSocketDisabled(disabled?: boolean): boolean {\n  const { isConnected, isReconnecting } = useSocket();\n\n  return disabled || !isConnected || isReconnecting;\n}\n\n/**\n * Hook to show connection-dependent UI feedback\n *\n * @returns Object with connection state and UI helpers\n *\n * @example\n * ```tsx\n * const { statusText, statusColor, showWarning } = useSocketStatus();\n * ```\n */\nexport function useSocketStatus() {\n  const { isConnected, isReconnecting, connectionError, reconnectAttempt, queuedMessageCount } = useSocket();\n\n  const statusText = isConnected\n    ? 'Connected'\n    : isReconnecting\n    ? `Reconnecting... (${reconnectAttempt})`\n    : 'Disconnected';\n\n  const statusColor = isConnected\n    ? 'text-green-600'\n    : isReconnecting\n    ? 'text-yellow-600'\n    : 'text-red-600';\n\n  const showWarning = !isConnected || isReconnecting;\n\n  return {\n    isConnected,\n    isReconnecting,\n    connectionError,\n    reconnectAttempt,\n    queuedMessageCount,\n    statusText,\n    statusColor,\n    showWarning,\n  };\n}\n\n/**\n * Hook to queue messages when socket is disconnected\n *\n * @returns Object with emit function and queue state\n *\n * @example\n * ```tsx\n * const { emit, queuedCount } = useSocketQueue();\n * emit('message:new', { content: 'Hello' });\n * ```\n */\nexport function useSocketQueue() {\n  const { emitWithQueue, queuedMessageCount, isConnected } = useSocket();\n\n  return {\n    emit: emitWithQueue,\n    queuedCount: queuedMessageCount,\n    isConnected,\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,6,11]}